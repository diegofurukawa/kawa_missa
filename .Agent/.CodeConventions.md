# Code Conventions

## 1. General Principles
- **Clarity over Cleverness**: Write readable, maintainable code.
- **Strict TypeScript**: Strict mode enabled. Avoid `any` types (some still exist - improvement area).
- **Functional**: Prefer functional components and hooks.
- **Server-First**: Use Server Components by default, Client Components only when needed.

## 2. Next.js & React
- Use **App Router** (`app/` directory).
- Use **Server Components** by default. Use `'use client'` only when interaction/state is needed.
- **Naming**:
    - Components: PascalCase (e.g., `UserCard.tsx`).
    - Utilities: camelCase (e.g., `formatDate.ts`).
    - Folders: kebab-case (e.g., `user-profile`).

## 3. Folder Structure
- `app/`: Routes and pages (Server Components by default).
- `app/ui/`: UI components organized by feature:
    - `app/ui/dashboard/`: Dashboard-specific components (sidenav, header, carousel, etc.)
    - `app/ui/masses/`: Mass-related forms and components
    - `app/ui/config/`: Configuration forms
    - `app/ui/organization/`: Organization forms
    - `app/ui/login/`: Login components
    - `app/ui/button.tsx`, `app/ui/tag.tsx`, etc.: Shared UI primitives
- `lib/`: 
    - `lib/actions.ts`: All server actions (with `'use server'` directive)
    - `lib/data.ts`: Data fetching functions
    - `lib/definitions.ts`: Type definitions and Zod schemas
    - `lib/prisma.ts`: Prisma client singleton instance
- `app/api/`: API routes (e.g., NextAuth routes)
- `prisma/`: Schema and migrations
- `types/`: Global or shared type definitions
- `auth.ts` & `auth.config.ts`: NextAuth configuration

## 4. Server Actions
- All server actions are centralized in `lib/actions.ts` with `'use server'` directive at the top.
- **Validation**: Use Zod schemas for input validation (e.g., `MassSchema`, `TenantSchema`).
- **Return Pattern**: 
    ```typescript
    {
        message?: string;
        errors?: Record<string, string[]>;
        success?: boolean;
    }
    ```
- **Error Handling**:
    - Handle Prisma errors (`Prisma.PrismaClientKnownRequestError`) with specific error codes (e.g., `P2002` for unique constraint violations).
    - Return user-friendly error messages in Portuguese.
    - Log errors with `console.error` for debugging.
- **After Operations**: Use `revalidatePath()` to invalidate cache and `redirect()` for navigation after successful mutations.
- **Authentication**: Check session with `await auth()` from `@/auth` before operations that require authentication.

## 5. Client Components
- Use `'use client'` directive at the top of the file when:
    - Component needs interactivity (onClick, onChange, etc.)
    - Component uses React hooks (useState, useEffect, etc.)
    - Component uses browser APIs
    - Component needs to access client-side context (e.g., SessionProvider)
- **Forms**: Use `useActionState` from React for server actions:
    ```typescript
    const [state, dispatch, isPending] = useActionState(serverAction, undefined);
    ```
- **Toast Notifications**: Use `toast` from `sonner`:
    - `toast.error(message)` for errors
    - `toast.success(message)` for success
    - Handle in `useEffect` when state changes

## 6. Forms & User Input
- Forms use Server Actions via `useActionState` hook.
- Form data is passed as `FormData` to server actions.
- Client-side validation can be added, but server-side validation with Zod is mandatory.
- Dynamic form fields (e.g., multiple participants per role) use prefixed keys:
    - Format: `role_${roleName}` for participants
    - Format: `cron_${index}` for cron expressions
    - Format: `role_${index}` and `qty_${index}` for role configurations
- Date and time inputs are combined into ISO datetime string before submission.

### 6.1. Date and Time Handling (CRITICAL)
- **Always use local time**: The application operates in Brazilian timezone (UTC-3).
- **Date Components**: Use `DateInput` and `TimeInput` components for all date/time inputs.
- **Format Standards**:
    - Date display: `dd/MM/yyyy` (Brazilian format)
    - Time display: `HH:mm` (24-hour format)
    - Internal storage: `YYYY-MM-DD` for dates, `HH:mm` for times
    - Combined: `YYYY-MM-DDTHH:mm` (ISO local format, NO timezone suffix)
- **Creating Dates**:
    - Use `fromLocalDateTime(str)` to convert `YYYY-MM-DDTHH:mm` to Date object
    - Use `createLocalDate(year, month, day, hours, minutes)` for manual creation
    - **NEVER use** `new Date(isoString)` with timezone - it converts to UTC
    - **ALWAYS use** `new Date(year, month-1, day, hours, minutes, 0, 0)` constructor
- **Database Storage**:
    - PostgreSQL stores as `timestamp with timezone` (converts to UTC internally)
    - When creating Date with local constructor, PostgreSQL preserves the local time
    - Example: Input `08:30` → Date object `08:30` → PostgreSQL stores as `08:30 -03:00` → Reads back as `08:30`
- **Formatting for Display**:
    - Use `formatLocalDateTime(date)` to get `{ date: 'YYYY-MM-DD', time: 'HH:mm' }`
    - Use `formatDateToBR(dateStr)` to convert `YYYY-MM-DD` to `dd/MM/yyyy`
- **Common Pitfalls to Avoid**:
    - ❌ Using `toISOString()` - converts to UTC
    - ❌ Using `new Date(string)` with ISO string - interprets as UTC
    - ❌ Using `setFullYear/setHours` separately - can cause timezone shifts
    - ✅ Using `new Date(year, month-1, day, hours, minutes, 0, 0)` - creates local Date
    - ✅ Using utility functions from `lib/date-utils.ts`


## 7. Styling (Tailwind CSS)
- Use utility classes directly.
- Use `clsx` for conditional class names (e.g., `clsx('base-class', { 'active-class': isActive })`).
- Avoid `@apply` in CSS files unless creating a reusable atomic class is strictly necessary.
- Mobile-first approach.
- **Custom Colors**:
    - Primary: `#6d7749` (green) - used for primary buttons, active states, brand elements
    - Secondary: `#6546b8` (purple) - used for secondary actions
    - Background: `#f6f5f8` (light gray) - used for sidebar and light backgrounds
- Use Tailwind's color utilities with custom values when needed: `bg-[#6d7749]`, `hover:bg-[#5d6541]`

### 7.1. UX/UI Best Practices
- **Fluid Components**: Avoid fixed positioning that overlaps content. Components should flow naturally with the page.
- **Non-Intrusive UI**: Use floating action buttons (FAB) and modals for secondary actions instead of persistent header buttons.
- **Modal Patterns**:
    - Use backdrop blur (`backdrop-blur-sm`) for better focus
    - Include smooth animations (`animate-in fade-in zoom-in`)
    - Always provide a clear close button
    - Stop propagation on modal content to prevent accidental closes
    - Example: `LoginModal` component for authentication access
- **Public Pages**:
    - Keep headers minimal and centered
    - Use floating action buttons for login/admin access
    - Ensure message banners are part of the page flow, not fixed overlays
    - Maintain consistent spacing with `space-y-8` for sections
- **Accessibility**:
    - Always include `aria-label` for icon-only buttons
    - Use semantic HTML elements
    - Ensure sufficient color contrast


## 8. Database (Prisma v7)
- Schema definitions in `prisma/schema.prisma`.
- Use strictly typed queries.
- **Client Setup**:
    - Database client instance is a singleton in `lib/prisma.ts`.
    - Uses Prisma adapter pattern with `@prisma/adapter-pg` for PostgreSQL.
    - Connection pooling with `pg.Pool` for better performance.
    - Singleton pattern prevents multiple instances in development.
- **Transactions**: Use `prisma.$transaction()` for multi-step operations (e.g., creating tenant + user).
- **Error Handling**: Check for `Prisma.PrismaClientKnownRequestError` with specific error codes.

### 8.1. Database Connection Configuration (Critical)
**NEVER use fallback values for database connection parameters.** If a configuration is invalid or missing, the application MUST fail fast with a clear error message.

- **Environment Variables**:
    - `DATABASE_URL`: Complete PostgreSQL connection string (preferred)
    - Individual variables (`DB_HOST`, `DB_PORT`, `DB_USER`, `DB_PASSWORD`, `DB_NAME`, `DB_SCHEMA`): Used as fallback
    - `DB_SSL`: Set to `'true'` or `'false'` (string) to control SSL mode
- **Valid Hostnames**:
    - Accept ANY valid hostname including:
        - IP addresses (e.g., `192.168.0.217`, `127.0.0.1`)
        - Domain names (e.g., `db.example.com`)
        - Docker service names (e.g., `host_database`, `postgres-service`)
    - **NEVER reject or replace valid hostnames** with fallbacks like `localhost`
    - **NEVER add logic** that treats certain hostnames as "invalid" (e.g., filtering out `host_database`)
- **SSL Configuration**:
    - Respect `DB_SSL` environment variable explicitly
    - When `DB_SSL='false'`, use `ssl: false` in pool configuration
    - When `DB_SSL='true'`, use `ssl: { rejectUnauthorized: false }` for self-signed certificates
    - Never assume SSL defaults - always read from environment
- **Docker Environment**:
    - Use Docker service names (e.g., `host_database`) instead of IPs when containers are in the same network
    - Do NOT use `DOCKER_BUILD` flag to override runtime connection parameters
    - Build-time and runtime use the same connection logic - no special cases
- **Connection Pool**:
    - Always configure timeouts (`connectionTimeoutMillis`, `idleTimeoutMillis`)
    - Add event listeners (`error`, `connect`) for debugging in production
    - Log connection strings with masked passwords for troubleshooting
- **Error Messages**:
    - Must be clear and actionable (e.g., "DB_HOST deve estar configurado")
    - Include what's missing and where to configure it
    - Do NOT suggest invalid workarounds

### 8.2. Migrations Best Practices
- **Consolidation**: Keep migrations minimal. Consolidate multiple migrations into one when:
    - Setting up a new environment
    - Migrations have incorrect timestamps/order
    - Reducing migration history complexity
- **Migration Naming**: Use timestamps in format `YYYYMMDDHHMMSS_description`
    - Ensure timestamps are in correct chronological order
    - Wrong: `20250101120000` (January) before `20251223154005` (December)
    - Correct: All dates in proper sequence
- **Production Resets**: Only reset production database when explicitly confirmed by team
    - Use `DROP SCHEMA public CASCADE` for complete reset
    - Alternative: Delete specific migration records from `_prisma_migrations` table
- **Single Source of Truth**: The Prisma schema file is the source of truth, not the migration history

## 9. Authentication (NextAuth v5)
- Using NextAuth v5 (beta) with credentials provider.
- Configuration split between:
    - `auth.config.ts`: Auth configuration (callbacks, pages, etc.)
    - `auth.ts`: NextAuth instance with providers and callbacks
- **Session**: Access session with `await auth()` in Server Components and server actions.
- **Client Session**: Use `useSession()` from `next-auth/react` in Client Components (wrapped in `SessionProvider`).
- **Middleware**: Configured in `middleware.ts` to protect routes.
- **JWT Callbacks**: Extend token with `id`, `role`, and `tenantId` for easy access in components.

### 9.1. Middleware Best Practices
- **Tenant Validation**: Always validate tenant existence for public routes that require a tenant parameter.
- **Graceful Redirects**: Instead of showing 404 errors, redirect users to `/select-tenant` when:
    - Tenant parameter is missing
    - Tenant doesn't exist in the database
    - Tenant validation fails
- **Error Handling**: Log errors but allow the request to continue (let the page handle edge cases).
- **Async Callbacks**: Use `async` in `authorized()` callback when database queries are needed.
- **Runtime Configuration**: When using Prisma or other Node.js modules in middleware, configure Node.js runtime:
    ```typescript
    // middleware.ts
    export const runtime = 'nodejs'; // Required for Prisma
    ```
    - Edge Runtime doesn't support Node.js modules like `crypto` (used by Prisma)
    - Without this, you'll get: `The edge runtime does not support Node.js 'crypto' module`
- **Example Pattern**:
    ```typescript
    if (isOnPublicDashboard) {
        const tenantId = nextUrl.searchParams.get('tenant');
        if (!tenantId) {
            return Response.redirect(new URL('/select-tenant?redirect=/dashboard/public', baseUrl));
        }
        try {
            const tenant = await prisma.tenant.findUnique({
                where: { id: tenantId },
                select: { id: true }
            });
            if (!tenant) {
                return Response.redirect(new URL('/select-tenant?redirect=/dashboard/public', baseUrl));
            }
        } catch (error) {
            console.error('Error validating tenant:', error);
            // Allow continuation - page will handle it
        }
        return true;
    }
    ```

### 9.2. Public Page Patterns
- **Tenant Validation**: Always check if tenant exists and redirect to `/select-tenant` if not found.
- **No 404 for Missing Tenants**: Use `redirect()` instead of `notFound()` for better UX.
- **Example**:
    ```typescript
    const tenant = await getTenantBySlug(tenantSlug);
    if (!tenant) {
        redirect('/select-tenant?redirect=/dashboard/public');
    }
    ```


## 10. Feedback (Sonner)
- Use `sonner` for all user-facing notifications (success, error, info).
- Configure the `Toaster` component at the root layout (`app/layout.tsx`).
- **Usage in Client Components**:
    ```typescript
    import { toast } from 'sonner';
    
    useEffect(() => {
        if (state?.message) {
            toast.error(state.message);
        }
    }, [state?.message]);
    ```
- Use Portuguese messages for user-facing notifications.

## 11. Imports
- **Absolute imports** (preferred for):
    - `@/lib/*` - Server actions, data fetching, utilities
    - `@/auth` - Authentication
    - `@/app/ui/*` - UI components (when importing from pages)
- **Relative imports** (acceptable for):
    - Same directory or nearby components (e.g., `../button`, `./tag-input`)
    - When importing from sibling files in the same feature folder
- **Examples**:
    ```typescript
    import { createMass } from '@/lib/actions';
    import { auth } from '@/auth';
    import { Button } from '../button';
    import { TagInput } from '../tag-input';
    ```

## 12. TypeScript
- Strict mode enabled in `tsconfig.json`.
- **Type Definitions**:
    - Shared types and Zod schemas in `lib/definitions.ts`
    - Inline types for component-specific props
    - Extend NextAuth types in `types/next-auth.d.ts`
- **Improvement Area**: Some `any` types still exist (e.g., `tenant: any` in form props). These should be replaced with proper types.

## 13. Data Fetching
- Data fetching functions in `lib/data.ts`.
- Functions are async and return typed data.
- Use Prisma queries with proper type inference.
- Handle errors gracefully and return null/empty arrays when appropriate.

## 14. Error Handling Patterns
- **Server Actions**: Return error objects with `message` field, handle Prisma errors specifically.
- **Client Components**: Use `useEffect` to watch for error states and show toast notifications.
- **User Messages**: All error messages should be in Portuguese and user-friendly.
- **Logging**: Use `console.error` for debugging server-side errors (avoid exposing sensitive info to clients).

## 15. Debugging & Troubleshooting
- **Database Connection Issues**:
    - Always add detailed logging in connection setup (with masked passwords)
    - Log the actual connection string being used at runtime
    - Use pool event listeners (`error`, `connect`) to track connection lifecycle
    - Common issue: Runtime using different config than build-time (check for `DOCKER_BUILD` flag misuse)
- **Docker Deployment**:
    - Verify environment variables are correctly set in Portainer/docker-compose
    - Check if container is using cached image (`docker rmi` to force rebuild)
    - Inspect container environment: `docker exec <container> env`
    - Check DNS resolution: Container should use service names (e.g., `host_database`), not IPs
- **Migration Failures**:
    - Error P3009 (failed migrations): Check `_prisma_migrations` table for failed records
    - Clear failed migrations: `DELETE FROM _prisma_migrations WHERE finished_at IS NULL`
    - Verify migration order: Timestamps must be chronological
    - Never commit migrations with wrong dates
- **ECONNREFUSED Errors**:
    - Usually indicates wrong hostname or port
    - Check if using correct Docker service name vs localhost/IP
    - Verify SSL configuration matches database requirements
    - Ensure database container is running and accessible from app container
